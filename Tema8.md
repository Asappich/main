# Тема 8. Введение в ООП
Отчёт по теме выполнил:
  - Плашкин Денис Владимирович 
  - ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + | 
| Задание 3 | + | + | 
| Задание 4 | + | + |
| Задание 5 | + | + | 
| Задание 6 | - | - | 
| Задание 7 | - | - | 
| Задание 8 | - | - | 
| Задание 9 | - | - | 
| Задание 10 | - | - | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторные задания:

### №1. 
Создайте класс "Car" с атрибутами производитель и модель. Создайте объект этого класса. Напишите компоненты для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с компонентами.
### Ответ: 
```python
class Car:  # Определение класса 'Car'
    def __init__(self, make, model):  # Метод инициализации экземпляра класса
        self.make = make  # Присваивание значения параметра 'make' атрибуту 'make' объекта
        self.model = model  # Присваивание значения параметра 'model' атрибуту 'model' объекта

# Создание экземпляра класса 'Car' с параметрами 'Toyota' и 'Corolla'
my_car = Car("Toyota", "Corolla")
# Вывод информации об автомобиле на экран
print(f"Бренд: {my_car.make}, Модель: {my_car.model}")
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/1.jpg)

### Вывод: 
Класс Car описывает автомобиль. Конструктор __init__ принимает два аргумента: марка (make) и модель (model), которые затем сохраняются в соответствующих атрибутах объекта. Далее создается экземпляр my_car класса Car, где передаются значения "Toyota" и "Corolla". После этого выводятся данные об автомобиле – его бренд и модель.

### №2. 
Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Ответ: 
```python
# Определение класса Car
class Car:
    # Метод инициализации, который вызывается при создании нового экземпляра класса
    def __init__(self, make, model):
        # Сохранение марки автомобиля в атрибуте 'make'
        self.make = make
        # Сохранение модели автомобиля в атрибуте 'model'
        self.model = model

    # Метод для имитации вождения автомобиля
    def drive(self):
        # Вывод сообщения о вождении текущего автомобиля
        print(f"Driving the {self.make} {self.model}")

# Создание экземпляра класса Car с маркой Toyota и моделью Corolla
my_car = Car("Toyota", "Corolla")
# Вызов метода drive у созданного экземпляра my_car
my_car.drive()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/2.jpg)

### Вывод: 
В приведенном коде определен класс Car, представляющий автомобиль. Класс имеет два атрибута: make (марка) и model (модель), которые устанавливаются при создании экземпляра через метод __init__. Кроме того, у класса есть метод drive, который выводит сообщение о движении автомобиля. В завершение создается объект my_car класса Car для автомобиля марки "Toyota" модели "Corolla", а затем вызывается метод drive.

### №3. 
Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Ответ: 
```python
# Определение класса Car, который представляет автомобиль
class Car:
    # Метод инициализации экземпляра класса Car
    def __init__(self, make, model):
        # Сохранение марки автомобиля в атрибуте 'make'
        self.make = make
        # Сохранение модели автомобиля в атрибуте 'model'
        self.model = model
    # Метод для управления автомобилем
    def drive(self):
        # Вывод сообщения о вождении автомобиля
        print(f"Driving the {self.make} {self.model}")

# Класс ElectricCar, наследующий от класса Car
class ElectricCar(Car):
    # Метод инициализации экземпляра класса ElectricCar
    def __init__(self, make, model, battery_capacity):
        # Вызов метода инициализации родительского класса Car
        super().__init__(make, model)
        # Сохранение емкости батареи в атрибуте 'battery_capacity'
        self.battery_capacity = battery_capacity
    # Метод зарядки электромобиля
    def charge(self):
        # Вывод сообщения о зарядке электромобиля
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")

# Создание экземпляра класса ElectricCar
my_electric_car = ElectricCar("Tesla", "Model S", 100)
# Вызов метода вождения для созданного экземпляра
my_electric_car.drive()
# Вызов метода зарядки для созданного экземпляра
my_electric_car.charge()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/3.jpg)

### Вывод: 
Код содержит реализацию двух классов: Car и ElectricCar. Класс Car служит базовой моделью автомобиля, имеющей такие характеристики, как марка (make) и модель (model), а также метод drive, который выводит сообщение о движении автомобиля. Класс ElectricCar наследует свойства и методы от Car, добавляя к ним новый параметр — емкость аккумулятора (battery_capacity), а также метод charge, позволяющий заряжать электромобиль. В завершении создается объект типа ElectricCar, после чего вызываются методы drive и charge.

### №4. 
Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Ответ: 
```python
class Car:  # Определение класса 'Car'
    def __init__(self, make, model):  # Конструктор класса, вызывается при создании экземпляра
        self._make = make  # Присваивание значения аргумента 'make' переменной экземпляра '_make'
        self.__model = model  # Присваивание значения аргумента 'model' переменной экземпляра '__model' (с использованием двойного подчеркивания для создания "псевдо-приватной" переменной)
    def drive(self):  # Метод класса, который выводит сообщение о вождении автомобиля
        print(f"Driving the {self._make} {self.__model}")  # Форматированный вывод строки с маркой и моделью автомобиля

# Создание экземпляра класса 'Car' с параметрами 'Toyota' и 'Corolla'
my_car = Car("Toyota", "Corolla")
# Доступ к защищённой переменной '_make' через экземпляр 'my_car'
print(my_car._make)
# Вызов метода 'drive' у экземпляра 'my_car', который выведет строку с маркой и моделью автомобиля
my_car.drive()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/4.jpg)

### Вывод: 
Класс Car описывает автомобиль, имеющий два атрибута: марку _make и модель __model, а также метод drive, который сообщает о движении автомобиля. В примере создается экземпляр класса Car, соответствующий автомобилю марки "Toyota" модели "Corolla". Затем выводится марка автомобиля через доступный атрибут _make, после чего вызывается метод drive.

### №5. 
Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Ответ: 
```python
# Определение базового класса для геометрических фигур
class Shape:
    # Абстрактный метод для вычисления площади фигуры
    def area(self):
        pass

# Класс прямоугольника, наследующий от класса Shape
class Rectangle(Shape):
    # Конструктор класса, принимающий ширину и высоту прямоугольника
    def __init__(self, width, height):
        # Сохранение ширины и высоты в экземпляре класса
        self.width = width
        self.height = height
    # Метод для вычисления площади прямоугольника
    def area(self):
        # Возвращает произведение ширины и высоты
        return self.width * self.height

# Класс круга, также наследующий от класса Shape
class Circle(Shape):
    # Конструктор класса, принимающий радиус круга
    def __init__(self, radius):
        # Сохранение радиуса в экземпляре класса
        self.radius = radius
    # Метод для вычисления площади круга
    def area(self):
        # Возвращает площадь круга по формуле π * r^2
        return 3.14 * self.radius ** 2

# Создание списка объектов фигур (прямоугольник и круг)
shapes = [Rectangle(4, 5), Circle(5)]
# Проход по всем фигурам в списке и вывод их площадей
for shape in shapes:
    # Вывод строки с площадью текущей фигуры
    print(f"Площадь: {shape.area()}")
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/5.jpg)

### Вывод: 
Этот код иллюстрирует применение полиморфизма посредством наследования классов. Класс Shape выступает в роли базового класса для геометрических фигур, тогда как классы Rectangle и Circle наследуются от него и переопределяют метод area() для расчета площади соответствующей фигуры. В главной части программы создается список объектов различных типов (прямоугольники и круги), и далее с использованием цикла вызывается метод area() для каждого объекта, что позволяет вычислить их площади, не зная точного типа фигуры.

## Самостоятельные задания:

### №1. 
Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Ответ: 
```python
class Animal:
    def __init__(self, name, klass):
        self.name = name
        self.klass = klass

animal_instance = Animal("лев", "млекопитающие")
print(f'Это животное — {animal_instance.name}, оно относится к классу {animal_instance.klass}.')
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/1s.jpg)

### Вывод: 
В представленном коде описан класс Animal, служащий моделью для животных. Этот класс включает два атрибута: name (название животного) и klass (классификация животного). Затем создается экземпляр класса под названием an_animal, которому присваиваются значения: имя «лев» и классификация «млекопитающие». В завершение программа выводит сведения об этом животном на экран.

### №2. 
Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Ответ: 
```python
class Animal:
    def __init__(self, name, klass):
        self.name = name
        self.klass = klass

    def place(self):
        location = input(f'Где обитает {self.name}? ')
        print(f"{self.name} действительно обитает в {location}")

animal = Animal("лев", "млекопитающие")
animal.place()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/2s.jpg)

### Вывод: 
Класс Animal является основой для описания животных. Он содержит два атрибута: name (имя животного) и klass (его класс). Метод place() запрашивает у пользователя данные о среде обитания животного и выводит подтверждение введенного значения. В примере создается объект класса Animal, представляющий льва, и затем вызывается метод place().

### №3. 
Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Ответ: 
```python
class Animal:
    def __init__(self, name, klass):
        self.name = name
        self.klass = klass

    def place(self):
        habitat = input(f'Где обитает {self.name}? ')
        print(f'{self.name} действительно обитает в {habitat}')

class Pet(Animal):
    def __init__(self, name, pet_name):
        super().__init__(name, 'домашнее животное')
        self.pet_name = pet_name

    def home(self):
        has_pet = input('Есть ли у вас домашний питомец? ')
        if has_pet.lower() == 'да':
            print(f'Вашего питомца зовут {self.pet_name} и он является {self.name}')
        else:
            print(f'К сожалению, {self.name} {self.pet_name} не является вашим питомцем')

my_pet = Pet('попугай', 'Кеша')
my_pet.place()
my_pet.home()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/3s.jpg)

### Вывод: 
В коде представлены два класса: Animal и Pet, последний из которых наследуется от первого. Класс Animal включает метод place, который запрашивает у пользователя данные о месте обитания животного. Класс Pet расширяет функциональность родительского класса методом home, который проверяет, является ли животное домашним питомцем, и выводит соответствующее сообщение. В заключение создается объект класса Pet и вызываются методы place и home.

### №4. 
Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Ответ: 
```python
class Animal:
    def __init__(self, name, klass):
        self._name = name
        self.__klass = klass

    def place(self):
        habitat = input(f'Введите среду обитания {self._name}: ')
        print(f'Верно, {self._name} принадлежит к классу {self.__klass} и обитает {habitat}')

animal = Animal("кузнечик", "насекомое")
print(animal._name)
animal.place()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/4s.jpg)

### Вывод: 
Класс Animal моделирует животное с двумя ключевыми характеристиками: именем _name и классом __klass, которое является защищённым полем. Метод place() запрашивает у пользователя данные о среде обитания животного и выводит сообщение, включающее имя, класс и указанное место обитания. В примере создаётся объект класса Animal, представляющий кузнечика, после чего вызывается метод place().

### №5. 
Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Ответ: 
```python
class Animals:
    def sound(self):
        pass
    
    def get_name(self):
        pass

class Cow(Animals):
    def __init__(self, name):
        self.name = name
        
    def get_name(self):
        return self.name
    
    def sound(self):
        print("Му-му")

class Cat(Animals):
    def __init__(self, name):
        self.name = name
        
    def get_name(self):
        return self.name
    
    def sound(self):
        print("Мяу-мяу")

class Dog(Animals):
    def __init__(self, name):
        self.name = name
        
    def get_name(self):
        return self.name
    
    def sound(self):
        print("Гав-гав")

animals = [Cow('Мушка'), Cat('Мари'), Dog('Рекс')]

for animal in animals:
    print(f"Имя животного: {animal.get_name()}")
    animal.sound()
```
![Меню](https://github.com/Asappich/main/blob/Tema8/pic/5s.jpg)

### Вывод: 
В этом коде показана иерархия классов для представления животных с применением механизма наследования. Основной класс Animals задает методы sound() и get_name(), которые переопределены в производных классах Cow, Cat и Dog. Каждый из этих подклассов устанавливает имя животного через конструктор и реализует собственные версии методов get_name() и sound(). В основной части программы создается список объектов разных видов животных (корова, кошка, собака), и с помощью цикла выводятся их имена и издаваемые ими звуки.

# Общий вывод по теме:
Объектно-ориентированное программирование (ООП) — это мощный подход к разработке программного обеспечения, основанный на работе с объектами, являющимися экземплярами классов. Основные принципы ООП включают:
  1. Классы и объекты: Классы выступают в качестве шаблонов для создания объектов, определяющих их структуру и функции.
  2. Атрибуты и методы: Атрибуты описывают состояние объекта, а методы определяют его поведение.
  3. Наследование: Позволяет создавать новые классы на базе уже существующих, что упрощает повторное использование кода и помогает строить иерархии классов.
  4. Инкапсуляция: Скрывает внутренние механизмы работы класса, обеспечивая контроль над доступом к его элементам.
  5. Полиморфизм: Разрешает объектам разных классов использовать одинаковый интерфейс, реагируя на одни и те же операции различным образом.
ООП способствует созданию структурированного, гибкого и легко поддерживаемого кода. Разработчики могут сосредотачиваться на моделировании объектов и их взаимодействий, игнорируя детали реализации. Это повышает качество архитектуры программных систем, облегчая их сопровождение и расширение.
