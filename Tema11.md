# Тема 11. Итераторы и генераторы
Отчёт по теме выполнил:
  - Плашкин Денис Владимирович
  - ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + | 
| Задание 3 | + | - | 
| Задание 4 | + | - |
| Задание 5 | + | - | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторные задания:

### №1. 
Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev()
### Ответ: 
```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
  print(item)
```
![Меню]()

### Вывод: 
Код создает список чисел от 0 до 5 и выводит каждое число на экран с помощью цикла for.

### №2. 
Класс итератор с гибкой настройкой и удобными применением
### Ответ: 
```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1

    def __iter__(self):
        return self

    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count


counter = CountDown(6)
for i in counter:
    print(i)
```
![Меню]()

### Вывод: 
Класс CountDown реализует обратный отсчет от заданного числа до нуля. При создании экземпляра класса через метод __init__ начальное значение увеличивается на единицу для корректной работы итератора. Метод __iter__ возвращает сам объект, а метод __next__ уменьшает счетчик и возвращает текущее значение, пока оно не станет отрицательным, после чего возбуждается исключение StopIteration, прекращающее цикл. В результате выполнения кода будет напечатан обратный отсчет: 6, 5, 4, 3, 2, 1, 0.

### №3. 
Генератор списка
### Ответ: 
```python
a = [i ** 2 for i in range (1, 5)]

print ('a - ', a)
for i in a:
    print(i)

print ('iter(a) - ', iter(a))
for i in a:
    print(i)
```
![Меню]()

### Вывод: 
В данном коде создается список a, содержащий квадраты чисел от 1 до 4, после чего этот список дважды выводится на экран: сначала целиком, а затем поэлементно. Также создается итератор для списка a с помощью функции iter(), но он не используется.

### №4. 
Выражения генераторы
### Ответ: 
```python
b = (i ** 2 for i in range(1,5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```
![Меню]()

### Вывод: 
В этом коде создается генератор b, который генерирует квадраты чисел от 1 до 4. Генераторы являются одноразовыми итераторами, то есть после того, как они были исчерпаны (например, при прохождении через цикл for), их нельзя использовать повторно без пересоздания. Поэтому первый цикл for выведет числа 1, 4, 9, 16, а второй цикл ничего не выведет, так как генератор уже был исчерпан.

### №5. 
Такой же счетчик, как и в первом задании, только это генератор и использует yield
### Ответ: 
```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1

if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```
![Меню]()

### Вывод: 
Код представляет собой функцию countdown, которая использует генератор для обратного отсчета от заданного числа до нуля включительно. В основной части программы создается экземпляр генератора с начальным значением 5, после чего элементы генератора выводятся в цикле for. Таким образом, программа напечатает числа от 5 до 0.

## Самостоятельные задания

### №1. 
Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.
### Ответ: 
```python
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

fibonacci_numbers = list(fib(200))

print(f"200-е число Фибоначчи: {fibonacci_numbers[-1]}")
```
![Меню]()

### Вывод: 
Код вычисляет числа Фибоначчи до 200-го элемента последовательности включительно, используя генератор fib. В результате создается список первых 200 чисел Фибоначчи, а затем выводится последнее число этого списка, то есть 200-е число Фибоначчи.

### №2. 
К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла.
### Ответ: 
```python
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

with open('fib.txt', 'w') as f:
    fibonacci_numbers = fib(200)
    f.writelines(f"{num}\n" for num in fibonacci_numbers)
```
![Меню]()
![Меню]()

### Вывод: 
Данный код генерирует последовательность чисел Фибоначчи до 200-го числа и записывает их в файл fib.txt, каждый элемент на новой строке. Функция fib использует генератор для последовательного вычисления чисел Фибоначчи, а цикл for в контексте менеджера контекста with обеспечивает запись каждого числа в файл.

# Общий вывод по теме:
Тема 11 посвящена итераторам и генераторам в Python, которые являются мощными инструментами для работы с последовательностями данных. Итераторы позволяют последовательно обходить элементы коллекций, таких как списки и строки, без необходимости знать их внутреннюю структуру. Генераторы, в свою очередь, представляют собой более эффективный способ создания итераторов, позволяя генерировать значения по мере необходимости и экономя память. Они работают на основе ленивой вычислительности, что делает их особенно полезными для обработки больших или бесконечных последовательностей данных. Генераторные выражения обеспечивают компактный синтаксис для создания генераторов. Основные преимущества использования генераторов включают экономию памяти, эффективность обработки больших данных, удобство и возможность создания бесконечных последовательностей. В целом, итераторы и генераторы являются важными инструментами для оптимизации работы с данными в Python.
