# Тема 10. Декораторы и исключения
Отчёт по теме выполнил:
  - Плашкин Денис Владимирович 
  - ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + | 
| Задание 3 | + | + | 
| Задание 4 | + | + |
| Задание 5 | + | + | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторные задания:

### №1. 
Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи. P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.
### Ответ: 
```python
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)

if __name__ == '__main__':
    print(fibonacci(100))
```
![Меню](https://github.com/Asappich/main/blob/Tema10/pic/1.jpg)

### Вывод: 
Импортируется модуль functools и функция lru_cache из этого модуля. Эта функция используется для кеширования результатов вычислений, чтобы избежать повторных вычислений одних и тех же значений.
Декорирует функцию fibonacci с параметром lru_cache, чтобы кэшировать результаты для ускорения последующих вычислений.
Внутри функции fibonacci, проводится проверка условия: если n равно 0 или 1, возвращается соответствующее значение (0 или 1). Если условие не выполнено, вычисляются предыдущие значения последовательности и суммируются.
В блоке if __name__ == '__main__' вызывается функция fibonacci(100), и результат выводится на печать.

### №2. 
Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.
### Ответ: 
```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = "Недопустимый возраст"
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name}   Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Алексадр', -5)
    personal_info('Петр', 138, 15, 48, 2)
```
![Меню](https://github.com/Asappich/main/blob/Tema10/pic/2.jpg)

### Вывод: 
Функция personal_info принимает два аргумента: name и age. Она выводит информацию в виде строки: Name: Владимир   Age: 38.
Функция output_func декорируется декоратором check, который проверяет входные аргументы. Если возраст меньше нуля или больше 130, то возраст заменяется на строку "Недопустимый возраст".
В блоке if __name__ == '__main__' вызывается функция personal_info, передавая разные значения возраста. При этом функция check проверяет допустимые значения возраста.

### №3. 
Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.
### Ответ: 
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value
    
    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
![Меню](https://github.com/Asappich/main/blob/Tema9/pic/3.jpg)

### Вывод: 
В данном коде реализован класс MyClass с использованием свойства value, которое управляется методами getter, setter и deleter. Объект obj создается с начальным значением 42. Вызывается метод get_value(), который возвращает значение 42, установленное ранее. Значение изменяется на 45 с помощью метода set_value(). Теперь метод get_value() возвращает новое значение 45. Еще одно изменение значения на 100. Последний вызов get_value выводит значение 100. После удаления значения с помощью del_value(), попытка вызова метода get_value() вызывает ошибку.

### №4. 
Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
### Ответ: 
```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
![Меню](https://github.com/Asappich/main/blob/Tema9/pic/4.jpg)

### Вывод: 
Создаем класс Mammal, который служит базовым классом для других классов. У него есть атрибут className, который указывает на вид млекопитающих.
Далее создаются классы Dog и Cat, которые наследуют класс Mammal. Они добавляют свои собственные атрибуты, такие как species и sounds, которые определяют вид млекопитающего и звуки, которые они издают. В конце создаются объекты классов Dog и Cat и выводятся сообщения, основанные на их характеристиках.

### №5. 
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.
### Ответ: 
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
![Меню](https://github.com/Asappich/main/blob/Tema9/pic/5.jpg)

### Вывод: 
Создается класс Russian, который содержит статический метод greeting(), который печатает "Привет".
Создаются объекты класса Russian и English, и для каждого объекта вызывается метод greeting() соответствующего класса.
Когда вызывается greet(ivan), выводится сообщение "Привет", так как объект ivan относится к классу Russian.
Когда вызывается greet(john), появляется сообщение "Hello", так как john относится к классу English.

## Самостоятельные задания:

### №1. 
Задание Садовник и помидоры.
### Ответ: 
```python
class Tomato:
    
    states = {'Отсутствует': 0, 'Цветение': 1, 'Зеленый': 2, 'Красный': 3}
    
    def __init__(self, index):
        self._index = index
        self._state = self.states['Отсутствует']
        
    def grow(self):
        if self._state < 3:
            self._state += 1
        
    def is_ripe(self):
        return True if self._state == 3 else False
 
class TomatoBush:
    
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(1, num+1)]
        
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
            
    def all_are_ripe(self):
        return all([tomato.is_ripe() for tomato in self.tomatoes])
    
    def give_away_all(self):
        self.tomatoes = []
 
class Gardener:
    
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant
        
    def work(self):
        self._plant.grow_all()
        
    def harvest(self):
        if self._plant.all_are_ripe():
            print('Урожай собран!')
            self._plant.give_away_all()
        else:
            print('Томаты еще не дозрели')
            
    @staticmethod
    def knowledge_base():
        print('Справка по садоводству:')
        print('1. Не забывайте регулярно поливать и подкармливать растения')
        print('2. Определите правильное расстояние между растениями, чтобы они не мешали друг другу в росте')
        print('3. Удалите поврежденные листья и плоды, чтобы предотвратить распространение болезней')
        
# ТЕСТ1.Вызов справки по садоводству
Gardener.knowledge_base()
 
# ТЕСТ2.Создание объектов классов TomatoBush и Gardener
bush = TomatoBush(5)
gardener = Gardener('John', bush)
 
# ТЕСТ3.Уход за кустом с помидорами
gardener.work()
gardener.work()
gardener.work()
 
# ТЕСТ4.Сбор урожая
gardener.harvest()
 
# Продолжение ухода за кустом, пока томаты не дозреют
gardener.work()
gardener.harvest()
gardener.work()
gardener.harvest()
gardener.work()
gardener.harvest()

# ТЕСТ5.Сбор урожая после дозревания всех томатов
gardener.work()
gardener.harvest()
```
![тест1](https://github.com/Asappich/main/blob/Tema9/pic/1s.jpg)
![тест2](https://github.com/Asappich/main/blob/Tema9/pic/2s.jpg)
![тест3](https://github.com/Asappich/main/blob/Tema9/pic/3s.jpg)
![тест4](https://github.com/Asappich/main/blob/Tema9/pic/4s.jpg)
![тест5](https://github.com/Asappich/main/blob/Tema9/pic/5s.jpg)

### Вывод: 
Класс Tomato описывает рост одного помидора. Помидоры проходят четыре стадии роста: отсутствие, цветение, зеленый и красный. Метод grow() продвигает помидор на следующую стадию роста.
Класс TomatoBush представляет собой грядку с несколькими помидорами. 
Метод grow_all() продвигает все помидоры на грядке на одну ступень вперед.
Метод is_ripe() проверяет, созрел ли помидор до красного цвета.
Метод harvest() собирает урожай, когда все помидоры созревают.
Класс Gardener отвечает за уход за помидорами. Он выполняет различные действия, такие как полив, подкормка и борьба с вредителями.

